/**
 * Character Card Generator
 *
 * Client-side library for generating SillyTavern-compatible
 * Character Card V2 files.
 */

class CharacterCardGenerator {
  /**
   * Create Character Card V2 data structure
   *
   * @param {Object} options - Character data
   * @param {string} options.name - Character name
   * @param {string} options.description - Character description (parsed content)
   * @param {string} [options.personality] - Character personality
   * @param {string} [options.scenario] - Scenario text
   * @param {string} [options.firstMessage] - First message
   * @param {string[]} [options.tags] - Tags
   * @param {string} [options.creator] - Creator name
   * @returns {Object} Character Card V2 object
   */
  static createCardData(options) {
    const {
      name = 'Character',
      description = '',
      personality = '',
      scenario = '',
      firstMessage = '',
      tags = [],
      creator = 'Scrapitor',
    } = options;

    return {
      spec: 'chara_card_v2',
      spec_version: '2.0',
      data: {
        name,
        description,
        personality,
        scenario,
        first_mes: firstMessage,
        mes_example: '',
        creator_notes: 'Generated by Scrapitor',
        system_prompt: '',
        post_history_instructions: '',
        alternate_greetings: [],
        character_book: null,
        tags,
        creator,
        character_version: '1.0',
        extensions: {
          scrapitor: {
            generated_at: new Date().toISOString(),
            version: '2.0',
          },
        },
      },
    };
  }

  /**
   * Embed character card data into PNG image
   *
   * @param {File|Blob} imageFile - PNG image file
   * @param {Object} cardData - Character Card V2 data
   * @returns {Promise<Blob>} PNG with embedded character data
   */
  static async embedIntoPNG(imageFile, cardData) {
    // Convert card data to JSON and base64 encode
    const json = JSON.stringify(cardData);
    const base64 = btoa(unescape(encodeURIComponent(json)));

    // Embed into PNG using tEXt chunk with keyword "chara"
    const pngWithData = await PNGHandler.addTextChunk(imageFile, 'chara', base64);

    return pngWithData;
  }

  /**
   * Extract character card from PNG image
   *
   * @param {File|Blob} imageFile - PNG image with embedded data
   * @returns {Promise<Object|null>} Character Card V2 data or null
   */
  static async extractFromPNG(imageFile) {
    try {
      const base64Data = await PNGHandler.readTextChunk(imageFile, 'chara');

      if (!base64Data) {
        return null;
      }

      // Decode base64 and parse JSON
      const json = decodeURIComponent(escape(atob(base64Data)));
      const cardData = JSON.parse(json);

      // Validate spec
      if (cardData.spec !== 'chara_card_v2') {
        console.warn('Unsupported character card version:', cardData.spec);
      }

      return cardData;
    } catch (error) {
      console.error('Failed to extract character card:', error);
      return null;
    }
  }

  /**
   * Parse character name from content
   *
   * Tries to extract character name from first line or first tag
   */
  static extractCharacterName(content) {
    if (!content) return 'Character';

    // Try to find first line that looks like a name
    const lines = content.trim().split('\n');
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && trimmed.length < 50 && !trimmed.includes(':')) {
        return trimmed;
      }
    }

    return 'Character';
  }

  /**
   * Split parsed content into sections
   *
   * Attempts to identify personality, scenario, etc.
   */
  static parseContent(content, metadata = {}) {
    const sections = {
      description: content,
      personality: '',
      scenario: metadata.scenario || '',
      firstMessage: metadata.firstMessage || '',
    };

    // Try to extract sections based on headers
    const scenarioMatch = content.match(/Scenario[:\s]+(.+?)(?=\n\n|\n[A-Z]|$)/is);
    if (scenarioMatch && !sections.scenario) {
      sections.scenario = scenarioMatch[1].trim();
    }

    const personalityMatch = content.match(/Personality[:\s]+(.+?)(?=\n\n|\n[A-Z]|$)/is);
    if (personalityMatch) {
      sections.personality = personalityMatch[1].trim();
    }

    return sections;
  }

  /**
   * Validate character card data
   */
  static validate(cardData) {
    const errors = [];

    if (!cardData || typeof cardData !== 'object') {
      errors.push('Card data must be an object');
      return errors;
    }

    if (cardData.spec !== 'chara_card_v2') {
      errors.push('Invalid spec: must be "chara_card_v2"');
    }

    if (cardData.spec_version !== '2.0') {
      errors.push('Invalid spec_version: must be "2.0"');
    }

    if (!cardData.data || typeof cardData.data !== 'object') {
      errors.push('Missing or invalid data object');
      return errors;
    }

    const data = cardData.data;

    if (!data.name || typeof data.name !== 'string') {
      errors.push('Missing or invalid name');
    }

    if (typeof data.description !== 'string') {
      errors.push('Invalid description');
    }

    return errors;
  }

  /**
   * Download character card as PNG file
   *
   * @param {Blob} pngBlob - PNG blob with embedded data
   * @param {string} filename - Filename (without extension)
   */
  static downloadCard(pngBlob, filename = 'character') {
    const url = URL.createObjectURL(pngBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.png`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /**
   * Generate and download character card in one step
   *
   * @param {File|Blob} imageFile - PNG image
   * @param {Object} options - Character data options
   * @returns {Promise<void>}
   */
  static async generateAndDownload(imageFile, options) {
    // Create card data
    const cardData = this.createCardData(options);

    // Validate
    const errors = this.validate(cardData);
    if (errors.length > 0) {
      throw new Error('Invalid character card: ' + errors.join(', '));
    }

    // Embed into PNG
    const pngWithData = await this.embedIntoPNG(imageFile, cardData);

    // Download
    const filename = this.sanitizeFilename(options.name || 'character');
    this.downloadCard(pngWithData, filename);
  }

  /**
   * Sanitize filename
   */
  static sanitizeFilename(name) {
    return name.replace(/[^a-z0-9_\-]/gi, '_').substring(0, 50);
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = CharacterCardGenerator;
}
